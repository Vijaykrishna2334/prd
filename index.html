<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRD to Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: white;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            color: #000;
        }

        .api-key-section {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .api-key-section input {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-top: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }

        .tab {
            padding: 12px 30px;
            background-color: white;
            color: #666;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        .tab:hover {
            color: #000;
        }

        .tab.active {
            color: #000;
            border-bottom-color: #000;
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .chat-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            height: 600px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 8px;
            max-width: 80%;
        }

        .message.assistant {
            background: #f5f5f5;
            margin-right: auto;
        }

        .message.user {
            background: #000;
            color: white;
            margin-left: auto;
        }

        .message-content {
            white-space: pre-wrap;
            line-height: 1.5;
        }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
        }

        .upload-section {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
        }

        .file-input-wrapper {
            margin: 20px 0;
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 12px 30px;
            background-color: black;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .file-label:hover {
            background-color: #333;
        }

        .file-name {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }

        button {
            padding: 12px 30px;
            background-color: black;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin: 10px 5px;
        }

        button:hover:not(:disabled) {
            background-color: #333;
        }

        button:disabled {
            background-color: #999;
            cursor: not-allowed;
        }

        .content-wrapper {
            display: flex;
            gap: 20px;
            flex: 1;
        }

        .prd-section, .prototype-section {
            flex: 1;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: white;
            overflow: auto;
            max-height: calc(100vh - 400px);
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #000;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
        }

        .prd-content {
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.6;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #000;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #d32f2f;
            padding: 15px;
            background: #ffebee;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 4px solid #d32f2f;
        }

        .prototype-iframe-container {
            width: 100%;
            height: 100%;
            min-height: 500px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .prd-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PRD to Prototype</h1>

        <div class="api-key-section">
            <label for="apiKey">
                <strong>Gemini API Key:</strong>
                <input
                    type="password"
                    id="apiKey"
                    placeholder="Enter your Gemini API key"
                    autocomplete="off"
                />
            </label>
        </div>

        <div class="tabs">
            <button class="tab active" data-tab="generate-prd">Step 1: Generate PRD</button>
            <button class="tab" data-tab="create-prototype">Step 2: Create Prototype</button>
        </div>

        <!-- Generate PRD Tab -->
        <div id="generate-prd" class="tab-content active">
            <div class="chat-container">
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input-container">
                    <input
                        type="text"
                        class="chat-input"
                        id="chatInput"
                        placeholder="Type your message here..."
                        disabled
                    />
                    <button id="sendBtn" disabled>Send</button>
                </div>
            </div>
            <div class="prd-actions">
                <button id="startChatBtn">Start PRD Generation</button>
                <button id="downloadPrdBtn" disabled>Download PRD</button>
            </div>
        </div>

        <!-- Create Prototype Tab -->
        <div id="create-prototype" class="tab-content">
            <div class="upload-section">
                <div class="file-input-wrapper">
                    <input
                        type="file"
                        id="fileInput"
                        accept=".txt,.md,.doc,.docx,.pdf"
                    />
                    <label for="fileInput" class="file-label">
                        Choose PRD File
                    </label>
                    <div class="file-name" id="fileName">No file chosen</div>
                </div>

                <button id="generateBtn" disabled>Generate Prototype</button>
            </div>

            <div class="content-wrapper">
                <div class="prd-section">
                    <h2 class="section-title">PRD Content</h2>
                    <div id="prdContent" class="prd-content">
                        Upload a PRD file to see its content here...
                    </div>
                </div>

                <div class="prototype-section">
                    <h2 class="section-title">Generated Prototype</h2>
                    <div id="prototypeContent" class="prototype-iframe-container">
                        Your generated prototype will appear here...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State management
        let conversationHistory = [];
        let generatedPRD = null;
        let uploadedFileContent = null;

        // DOM elements
        const apiKeyInput = document.getElementById('apiKey');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');
        const startChatBtn = document.getElementById('startChatBtn');
        const downloadPrdBtn = document.getElementById('downloadPrdBtn');
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const generateBtn = document.getElementById('generateBtn');
        const prdContent = document.getElementById('prdContent');
        const prototypeContent = document.getElementById('prototypeContent');

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;

                // Update active tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Update active content
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(tabName).classList.add('active');
            });
        });

        // PRD Generation System Prompt
        const SYSTEM_PROMPT = `You are a professional Product Manager who is friendly, supportive, and efficient. Your job is to guide the user through a short discovery, teach key concepts in simple language, and generate a clear PRD.

OPERATING PRINCIPLES

* Relevance first. Ask only what you need to produce a strong PRD. Default to the shortest path.
* Two phase flow:

  1. Core Discovery: ask up to 7 high value questions.
  2. Targeted Deep Dive: ask only the follow ups required to fill gaps for the PRD sections that are still unclear.
* Teach briefly as you go. Before each question, give a one sentence explanation so the user learns while answering.
* Summarize and confirm. After every 2 to 3 answers, reflect back a crisp summary and confirm in one sentence.
* Assume sensibly. If the user is unsure, propose a practical default and mark it as an assumption. Keep an Assumptions list.
* No code. Focus on concepts, outcomes, risks, and measurement.
* Tone: plain, clear, and supportive.

CORE DISCOVERY QUESTIONS
Ask these one by one, adapting wording to the user's context. Stop early if you already have enough to draft a PRD.

1. Problem and value: In one or two lines, what problem are we solving and for whom? What changes for them when we succeed?
2. Primary user and JTBD: Who is the main user and what job are they trying to get done?
3. Outcomes and KPIs: What does success look like in numbers in the first 8 to 12 weeks? Pick up to 3 KPIs.
4. Scope v1: What must v1 do end to end for a single happy path?
5. Constraints: Any hard limits such as budget, timeline, compliance, or platform?
6. Existing assets: Do you already have data, content, APIs, brand voice, or a prototype we should leverage?
7. Risks: What are the top 2 ways this could fail?

TARGETED DEEP DIVE LOGIC
Only ask if needed to complete the PRD.

* Platform and channels: Web, mobile, desktop, or API only. Any ecosystem constraints such as iOS guidelines or enterprise SSO.
* AI specifics: model choice, latency expectations, hallucination tolerance, evaluation needs, guardrails.
* Data: sources, freshness, privacy, PII handling, storage, and retention.
* UX: key flows to support the happy path and required approvals.
* GTM: audience, positioning, launch slice, and rollout.

MICRO EDUCATION SNIPPETS
Use one line before each related question:

* KPI vs success criteria: KPIs are numeric outcome targets. Success criteria can include qualitative launch goals.
* Model vs prompt: Model is the engine. Prompt is the instruction that steers it.
* RAG vs fine tuning: RAG pulls facts at runtime. Fine tuning teaches stable patterns from examples.
* Human in the loop: Add review steps where risk or brand matters.

WORKING NOTES DURING DISCOVERY
Maintain three short lists while chatting and show them in each recap:

* Known Decisions
* Open Questions
* Assumptions

PRD GENERATION RULES
CRITICAL REQUIREMENT: When you have enough information, you MUST:
1. Say: "I will now generate prd.md based on what we agreed. Anything marked Assumption can be revised."
2. Output the COMPLETE PRD document using the EXACT structure below
3. Include ALL 16 sections with their emoji headers
4. Use the exact markdown table formats shown
5. Fill every section - use "TBD" or "Assumption" if information is missing
6. DO NOT create a simplified version - use this EXACT format

PRD OUTPUT FORMAT (prd.md)
YOU MUST USE THIS EXACT FORMAT WITH ALL SECTIONS BELOW:

# CONTENTS

Abstract
Business Objectives
KPI
Success Criteria
User Journeys
Scenarios
User Flow
Model Requirements
Data Requirements
Prompt Requirements
Testing & Measurement
Risks & Mitigations
Costs
Assumptions & Dependencies
Compliance/Privacy/Legal
GTM/Rollout Plan

## ðŸ“ Abstract

Brief description of product, purpose, and rationale.

## ðŸŽ¯ Business Objectives

Bullets that link product impact to business goals.

## ðŸ“Š KPI

| GOAL                           | METRIC        | QUESTION                                       |
| ------------------------------ | ------------- | ---------------------------------------------- |
| New User Growth                | # New Signups | How many signups are driven by this launch     |
| New User Retention             | D7 Retention  | Does this feature increase week one stickiness |
| (Add or remove rows as needed) |               |                                                |

## ðŸ† Success Criteria

Clear definition of success for this project such as press, churn, signups, conversion impact.

## ðŸš¶â€â™€ï¸ User Journeys

Short narrative of key journeys for the target user.

## ðŸ“– Scenarios

List primary scenarios. Example lines are fine if tailored to this product.

## ðŸ•¹ï¸ User Flow

High level flow for happy path and key alternatives. Use bullets if no diagram.

## ðŸ§° Functional Requirements

Describe features and expected behaviors with user stories and acceptance hints. Add screens if available.
Use a brief table for major auth and core flows:

| SECTION         | SUB-SECTION | USER STORY & EXPECTED BEHAVIORS | SCREENS      |
| --------------- | ----------- | ------------------------------- | ------------ |
| Signup          | Email       | Story and behaviors             | Links or TBD |
| Signup          | Google      | Story and behaviors             | Links or TBD |
| Login           | Email       | Story and behaviors             | Links or TBD |
| Login           | Google      | Story and behaviors             | Links or TBD |
| Forgot Password |             | Story and behaviors             | Links or TBD |

## ðŸ“ Model Requirements

| SPECIFICATION          | REQUIREMENT        | RATIONALE |
| ---------------------- | ------------------ | --------- |
| Open vs Proprietary    | Option             | Why       |
| Context Window         | Value              | Why       |
| Modalities             | Text, Vision, etc. | Why       |
| Fine Tuning Capability | Needed or not      | Why       |
| Latency                | Target P50 and P95 | Why       |
| Parameters             | If relevant        | Why       |

## ðŸ§® Data Requirements

* Fine tuning purpose
* Data preparation plan
* Quantity and coverage targets
* Ongoing collection plan
* Iterative fine tuning plan

## ðŸ’¬ Prompt Requirements

* Policy and refusal handling
* Personalization rules such as pronouns and tone
* Output format guarantees such as JSON schema
* Accuracy target tied to the Testing Plan

## ðŸ§ª Testing & Measurement

* Offline eval plan such as golden sets, rubric, and pass thresholds
* Online plan such as A/B design, guardrails, and rollback
* Live performance tracking and alerting

## âš ï¸ Risks & Mitigations

| RISK                                 | MITIGATION                                           |
| ------------------------------------ | ---------------------------------------------------- |
| Invalid JSON breaks downstream calls | Auto retry with repair and show graceful error state |
| Wrong pronouns or tone               | Store preferences and pass into prompts              |
| Harmful or restricted content        | Policy reminders and refusal flows                   |

## ðŸ’° Costs

* Development costs such as data, tuning, and QA
* Operational costs such as tokens, inference, or GPUs

## ðŸ”— Assumptions & Dependencies

Bulleted list of assumptions and external dependencies.

## ðŸ”’ Compliance/Privacy/Legal

* Regulatory notes
* Data governance, retention, and access controls

## ðŸ“£ GTM/Rollout Plan

* Milestones
* Launch strategy
* Phased rollout including beta and full launch

CLOSING
CRITICAL - MANDATORY OUTPUT REQUIREMENT:
1. You MUST output the complete PRD document using the EXACT format above with ALL 16 sections
2. Include ALL emoji headers (ðŸ“, ðŸŽ¯, ðŸ“Š, ðŸ†, ðŸš¶â€â™€ï¸, ðŸ“–, ðŸ•¹ï¸, ðŸ§°, ðŸ“, ðŸ§®, ðŸ’¬, ðŸ§ª, âš ï¸, ðŸ’°, ðŸ”—, ðŸ”’, ðŸ“£)
3. Include ALL markdown tables as specified
4. Do NOT skip sections - write "TBD" or "Assumption: [explanation]" if information is missing
5. Do NOT create your own simplified format
6. Do NOT just say "good luck" or provide a summary
7. The user needs to see the COMPLETE formatted PRD in your message to download it
8. After outputting the COMPLETE PRD, ask for feedback on scope, risks, and KPIs

CONVERSATION START
Introduce yourself briefly, then ask the user to describe their app idea in one or two lines to begin Core Discovery.`;

        // Start chat
        startChatBtn.addEventListener('click', async () => {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                alert('Please enter your Gemini API key first');
                return;
            }

            startChatBtn.disabled = true;
            chatInput.disabled = false;
            sendBtn.disabled = false;

            // Initialize conversation
            conversationHistory = [];
            chatMessages.innerHTML = '';

            // Get initial message from AI
            await sendSystemMessage(apiKey, true);
        });

        // Send message
        sendBtn.addEventListener('click', () => sendMessage());
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                alert('Please enter your Gemini API key');
                return;
            }

            // Add user message
            addMessage('user', message);
            conversationHistory.push({ role: 'user', parts: [{ text: message }] });

            chatInput.value = '';
            chatInput.disabled = true;
            sendBtn.disabled = true;

            // Get AI response
            await sendSystemMessage(apiKey, false);

            chatInput.disabled = false;
            sendBtn.disabled = false;
            chatInput.focus();
        }

        async function sendSystemMessage(apiKey, isFirst) {
            try {
                showLoading();

                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-03-25:generateContent?key=${apiKey}`;

                let contents;
                if (isFirst) {
                    contents = [
                        { role: 'user', parts: [{ text: SYSTEM_PROMPT }] },
                        { role: 'model', parts: [{ text: 'Understood. I will follow these instructions precisely.' }] },
                        { role: 'user', parts: [{ text: 'Please start the conversation.' }] }
                    ];
                } else {
                    contents = conversationHistory;
                }

                const requestBody = {
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                    }
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
                }

                const data = await response.json();

                if (!data.candidates || data.candidates.length === 0) {
                    throw new Error('No response generated from API');
                }

                const assistantMessage = data.candidates[0].content.parts[0].text;

                // Remove loading indicator
                const loadingMsg = chatMessages.querySelector('.message.loading');
                if (loadingMsg) loadingMsg.remove();

                // Add assistant message
                addMessage('assistant', assistantMessage);
                conversationHistory.push({ role: 'model', parts: [{ text: assistantMessage }] });

                // Check if PRD was generated - look for various PRD indicators
                const prdIndicators = [
                    '# CONTENTS',
                    '## ðŸ“ Abstract',
                    'Product Requirements Document',
                    'PRD:',
                    '### **1. Introduction & Vision**',
                    '**1. Introduction & Vision**',
                    'Problem Statement',
                    'Goals & Success Metrics'
                ];

                const isPRD = prdIndicators.some(indicator =>
                    assistantMessage.includes(indicator)
                );

                if (isPRD && assistantMessage.length > 1000) {
                    generatedPRD = assistantMessage;
                    downloadPrdBtn.disabled = false;
                }

            } catch (error) {
                const loadingMsg = chatMessages.querySelector('.message.loading');
                if (loadingMsg) loadingMsg.remove();
                addMessage('assistant', `Error: ${error.message}`);
            }
        }

        function addMessage(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;

            messageDiv.appendChild(contentDiv);
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showLoading() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant loading';
            messageDiv.innerHTML = '<div class="spinner"></div>';
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Download PRD
        downloadPrdBtn.addEventListener('click', () => {
            if (!generatedPRD) return;

            const blob = new Blob([generatedPRD], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'prd.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Prototype generation (existing functionality)
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                fileName.textContent = file.name;
                try {
                    const content = await readFile(file);
                    uploadedFileContent = content;
                    prdContent.textContent = content;
                    updateGenerateButton();
                } catch (error) {
                    showError(prdContent, 'Error reading file: ' + error.message);
                }
            } else {
                fileName.textContent = 'No file chosen';
                uploadedFileContent = null;
                prdContent.textContent = 'Upload a PRD file to see its content here...';
                updateGenerateButton();
            }
        });

        apiKeyInput.addEventListener('input', updateGenerateButton);

        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        function updateGenerateButton() {
            const apiKey = apiKeyInput.value.trim();
            const hasFile = uploadedFileContent !== null;
            generateBtn.disabled = !apiKey || !hasFile;
        }

        generateBtn.addEventListener('click', async () => {
            const apiKey = apiKeyInput.value.trim();

            if (!apiKey) {
                showError(prototypeContent, 'Please enter your Gemini API key');
                return;
            }

            if (!uploadedFileContent) {
                showError(prototypeContent, 'Please upload a PRD file first');
                return;
            }

            generateBtn.disabled = true;
            prototypeContent.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Generating prototype from PRD...</p>
                </div>
            `;

            try {
                const html = await callGeminiAPI(apiKey, uploadedFileContent);
                renderPrototype(html);
            } catch (error) {
                showError(prototypeContent, 'Error generating prototype: ' + error.message);
            } finally {
                generateBtn.disabled = false;
                updateGenerateButton();
            }
        });

        async function callGeminiAPI(apiKey, prdContent) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-03-25:generateContent?key=${apiKey}`;

            const prompt = `You are a web prototype generator. Read the following PRD (Product Requirements Document) and generate a complete, functional HTML prototype with inline CSS and JavaScript.

IMPORTANT INSTRUCTIONS:
- Return ONLY the HTML code, starting with <!DOCTYPE html>
- Do NOT wrap the code in markdown code blocks or backticks
- Do NOT include any explanatory text before or after the HTML
- Include all CSS inline in a <style> tag in the <head>
- Include all JavaScript inline in a <script> tag before the closing </body> tag
- Make the prototype fully functional and interactive
- Use modern, clean design principles
- Make it responsive and mobile-friendly

PRD Content:
${prdContent}

Generate the complete HTML prototype now (HTML only, no markdown formatting):`;

            const requestBody = {
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                }
            };

            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API request failed with status ${response.status}`);
            }

            const data = await response.json();

            if (!data.candidates || data.candidates.length === 0) {
                throw new Error('No response generated from API');
            }

            let htmlContent = data.candidates[0].content.parts[0].text;

            htmlContent = htmlContent.replace(/```html\n?/g, '');
            htmlContent = htmlContent.replace(/```\n?/g, '');
            htmlContent = htmlContent.trim();

            return htmlContent;
        }

        function renderPrototype(html) {
            prototypeContent.innerHTML = '';

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            const scripts = tempDiv.querySelectorAll('script');
            const scriptContents = [];

            scripts.forEach(script => {
                if (script.src) {
                    scriptContents.push({ type: 'external', src: script.src });
                } else {
                    scriptContents.push({ type: 'inline', content: script.textContent });
                }
                script.remove();
            });

            prototypeContent.innerHTML = tempDiv.innerHTML;

            scriptContents.forEach(script => {
                if (script.type === 'external') {
                    const scriptElement = document.createElement('script');
                    scriptElement.src = script.src;
                    prototypeContent.appendChild(scriptElement);
                } else {
                    try {
                        const scriptElement = document.createElement('script');
                        scriptElement.textContent = script.content;
                        prototypeContent.appendChild(scriptElement);
                    } catch (error) {
                        console.error('Error executing script:', error);
                    }
                }
            });
        }

        function showError(element, message) {
            element.innerHTML = `<div class="error">${message}</div>`;
        }
    </script>
</body>
</html>
